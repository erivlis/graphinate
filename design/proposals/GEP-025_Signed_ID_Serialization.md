# GEP-025: Signed ID Serialization

| Field       | Value                   |
|:------------|:------------------------|
| **GEP**     | 25                      |
| **Title**   | Signed ID Serialization |
| **Author**  | Eran Rivlis             |
| **Status**  | Withdrawn               |
| **Type**    | Standards Track         |
| **Created** | 2025-12-29              |
| **Updated** | 2025-12-29              |

## Abstract

This proposal introduces an optional cryptographic signing mechanism for Graphinate IDs. By wrapping the existing `repr()` + `ast.literal_eval()` serialization with an HMAC-SHA256 signature, we ensure that IDs cannot be tampered with, mitigating the security risks associated with `literal_eval` while preserving the type fidelity and simplicity of the current approach.

## Status: Withdrawn

This proposal has been withdrawn. The Council determined that this feature is **overengineering** for the core library. The risk profile of `ast.literal_eval` is low for this application, and the added complexity (key management, ID size bloat) is not justified. Users requiring high security can implement custom converters.

## Motivation

The current ID serialization uses `repr()` encoded in Base64. While efficient and type-safe for Python primitives, it relies on `ast.literal_eval()` for decoding.

**The Problem:**
If an attacker can manipulate the ID string, they might be able to construct a malicious payload that, when passed to `ast.literal_eval()`, causes resource exhaustion (DoS) or other unintended behavior, even if `literal_eval` prevents arbitrary code execution.

**The Solution:**
We can ensure that `ast.literal_eval()` is only ever called on strings that *we* generated by signing them.

## Specification

### 1. Configuration

A new configuration setting `GRAPHINATE_SECRET_KEY` (or similar) will control this feature.

*   **If `None` (Default):** Legacy behavior. No signing. Fast, compact, but potentially unsafe if exposed to untrusted input.
*   **If Set (String/Bytes):** Signed mode enabled.

### 2. Encoding Format

When signing is enabled, the ID structure changes:

**Logical Structure:**
`[Signature] + [Payload]`

*   **Payload:** The UTF-8 bytes of `repr(obj)`.
*   **Signature:** The HMAC-SHA256 digest of the Payload (32 bytes).

**Final Output:**
`Base64_URLSafe(Signature + Payload)`

### 3. Algorithm

**Signing:**
```python
key = get_secret_key()
payload = repr(obj).encode('utf-8')
signature = hmac.new(key, payload, hashlib.sha256).digest()
token = base64.urlsafe_b64encode(signature + payload).decode('ascii')
```

**Verifying:**
```python
data = base64.urlsafe_b64decode(token)
signature = data[:32]
payload = data[32:]

expected_signature = hmac.new(key, payload, hashlib.sha256).digest()
if not hmac.compare_digest(signature, expected_signature):
    raise SecurityError("Invalid ID Signature")

obj = ast.literal_eval(payload.decode('utf-8'))
```

### 4. Truncation (Optimization)

To save space, we may choose to truncate the HMAC.
*   Full SHA256: 32 bytes.
*   Truncated: 16 bytes (128 bits).
*   **Decision:** We will support full 32 bytes for maximum security. The overhead is acceptable for the safety gained.

## Backwards Compatibility

*   **Breaking Change (when enabled):** Enabling signing changes the ID format. IDs generated without signing will fail verification if signing is turned on (and vice versa, though unsigned IDs might just look like garbage to the decoder).
*   **Migration:** This is a server-side configuration. Toggling it invalidates all existing IDs. This is acceptable for session-based graphs.

## Security Considerations

*   **Key Management:** The secret key must be kept safe. If leaked, attackers can forge IDs.
*   **Replay Attacks:** This proposal does *not* prevent replay attacks (using an old valid ID). If replay protection is needed, a timestamp or nonce must be included in the payload.

## Reference Implementation

(Withdrawn)
